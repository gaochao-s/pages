<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="description" content="Mesh Silksong: Auto-Regressive Mesh Generation as Weaving Silk">
    <meta name="keywords" content="3D Mesh Generation, LLM, Point Cloud">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Mesh Silksong</title>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <link href="https://fonts.googleapis.com/css?family=Google+Sans|Noto+Sans|Castoro" rel="stylesheet">

    <link rel="stylesheet" href="./static/css/bulma.min.css">
    <link rel="stylesheet" href="./static/css/bulma-carousel.min.css">
    <link rel="stylesheet" href="./static/css/bulma-slider.min.css">
    <link rel="stylesheet" href="./static/css/fontawesome.all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">
    <link rel="stylesheet" href="./static/css/index.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
       
        .results-carousel {
            display: flex;
            flex-wrap: wrap;         
            justify-content: center; 
            align-items: flex-start; 
            gap: 20px;              
           
            
          }
          .caption-text {
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
        }

		.render_wrapper {
            position: relative;
            height: 300px;
            
            
        }
   
		.render_div {
			position: absolute;
			top: 0;
			left: 0;
		}

      @font-face {
            font-family: 'Trajan Pro';
            src: url('static/fonts/Trajan Pro Regular.ttf') format('truetype');
        }

        .publication-title {
            font-family: 'Trajan Pro', serif;
        }

        h2 {
            font-family: 'Trajan Pro', serif;
        }
       
    </style>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script defer src="./static/js/fontawesome.all.min.js"></script>
    <script src="./static/js/bulma-carousel.min.js"></script>
    <script src="./static/js/bulma-slider.min.js"></script>
    <script src="./static/js/index.js"></script>
    <!-- model viewer -->
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.1.1/model-viewer.min.js"></script>
    
</head>

<body>

    <section class="hero">
        <div class="hero-body">
            <div class="container is-max-desktop">
                <div class="columns is-centered">
                    <div class="column has-text-centered">
          <h1 class="title is-1 publication-title">Mesh Silksong: Auto-Regressive Mesh Generation as Weaving Silk</h1>
          <!-- <h3 class="title has-text-centered">CVPR 2024 (Oral, Best Paper Award Candidate)</h3> -->
          <div class="is-size-5 publication-authors">
            <span class="author-block">
              <a href="https://scholar.google.com/citations?user=5LbyDkcAAAAJ&hl=zh-CN" target="_blank" rel="noopener noreferrer">
                Gaochao Song</a><sup>1</sup>,
            </span>
            <span class="author-block">
              <a href="https://maikouuu.github.io/" target="_blank" rel="noopener noreferrer">
                Zibo Zhao</a><sup>2</sup>,
            </span>
            <span class="author-block">
              <a href="https://whaohan.github.io/" target="_blank" rel="noopener noreferrer">
                Haohan Weng</a><sup>2</sup>,
            </span>
            <span class="author-block">
              <a href="https://scholar.google.com/citations?user=kgkxDcoAAAAJ&hl=zh-CN" target="_blank" rel="noopener noreferrer">
                Jingbo Zeng</a><sup>1</sup>,
            </span>
            <span class="author-block">
              <a href="https://github.com/gaochao-s/Mesh-Silksong" target="_blank" rel="noopener noreferrer">
                Rongfei Jia</a><sup>3</sup>,
            </span>
            <span class="author-block">
              <a href="https://scholar.google.com.sg/citations?user=fe-1v0MAAAAJ&hl=en" target="_blank" rel="noopener noreferrer">
                Shenghua Gao</a><sup>1</sup>
            </span>
          </div>

          <div class="is-size-5 publication-authors">
            <span class="author-block"><sup>1</sup>University of Hong Kong, </span>
            <span class="author-block"><sup>2</sup>Tencent Hunyuan 3D, </span>
            <span class="author-block"><sup>3</sup>Math Magic</span>
          </div>

          <div class="column has-text-centered">
            <div class="publication-links">
              <span class="link-block">
                <a href="https://arxiv.org/abs/2507.02477" target="_blank" rel="noopener noreferrer"
                   class="external-link button is-normal is-rounded is-dark">
                  <span class="icon">
                      <i class="fas fa-file-pdf" style="color: orangered"></i>
                  </span>
                  <span>Paper</span>
                </a>
              </span>
              <!-- Code Link. -->
              <span class="link-block">
                <a href="https://github.com/gaochao-s/Mesh-Silksong" target="_blank" rel="noopener noreferrer"
                   class="external-link button is-normal is-rounded is-dark">
                  <span class="icon">
                      <i class="fab fa-github"></i>
                  </span>
                  <span>
                    Code
                  <!-- </span>
                  <img
                          src="https://img.shields.io/github/stars/prs-eth/marigold?style=for-the-badge&label=&color=333333&labelColor=333333" alt="GitHub stars"
                          style="margin-top: 3px;"
                  >
                  <span> -->
                    <!-- stars -->
                  </span>
                </a>
              </span>
              <!-- Hugging Face Space -->
              <span class="link-block">
                <a href="https://huggingface.co/gcsong/mesh_silksong/tree/main" target="_blank" rel="noopener noreferrer"
                   class="external-link button is-normal is-rounded is-dark">
                  <span class="icon">
                      &#129303;
                  </span>
                  <span>Check Points</span>
                </a>
              </span>
              
            </div>
          </div>
        </div>
                </div>
            </div>
        </div>
    </section>

    <section class="hero teaser">
  <div class="container is-max-desktop">
    <div class="hero-body"> 
      <video id="teaser" width="100%" autoplay loop muted  playsinline poster="./video/teaser_prview.png">
        <source src="./video/teaser_video_music.mp4" type="video/mp4">
        Your browser does not support the video tag.
      </video>
      <h3 class="subtitle has-text-centered">
        Meshes generated by Mesh Silksong. Vertices are colored based on different connected component of mesh. Our method is connected component aware based on special tokens when generating, which helps capture small but critical parts of mesh.
      </h3>
    </div>
  </div>
</section>

<section class="section pt-0">
  <div class="container is-max-desktop">
    <!-- Abstract. -->
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Abstract</h2>
        <div class="content has-text-justified">
          <p>
            We introduce Mesh Silksong, a compact and efficient mesh representation tailored to generate the polygon mesh in an auto-regressive manner akin to silk weaving. Existing mesh tokenization methods always produce token sequences with repeated vertex tokens, wasting the network capability. Therefore, our approach tokenizes mesh vertices by accessing each mesh vertice only once, reduces the token sequence’s redundancy by 50%, and achieves a state-of-the-art compression rate of approximately 22%. Furthermore, Mesh Silksong produces polygon meshes with superior geometric properties, including manifold topology, watertight detection, and consistent face normals, which are critical for practical applications. Experimental results demonstrate the effectiveness of our approach, showcasing not only intricate mesh generation but also significantly improved geometric integrity.
          </p>
        </div>
      </div>
    </div>
    <!--/ Abstract. -->
  </div>
</section>


    <section class="hero is-light is-small">

        <div>
            <h2>&nbsp</h2>
            <h2 class="title is-3" style="text-align: center;"> Gallery </h2>
            <div class="container", id="render-container">
                <p style="text-align: center;">
                    Mesh generated conditioned on point cloud. Left mouse: change view; Right mouse: move mesh.
                </p>
                <div id="results-carousel" class=" carousel results-carousel ">
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_001" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_cond_001" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_002" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_cond_002" class="render_div"></div>
                    </div>
                </div>
                <div id="results-carousel" class=" carousel results-carousel ">
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_003" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_cond_003" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_004" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_cond_004" class="render_div"></div>
                    </div>
                </div>
    
            </div>
            <h2>&nbsp</h2>
        </div>
        
    </section>
    <script>
        window.addEventListener("DOMContentLoaded", function() {
          var video = document.getElementById("teaser");
          video.playbackRate = 0.8; 
        });
      </script>

<section class="section">
  <div class="container is-max-desktop">
    <!-- Method. -->
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Algorithm Pipeline</h2>
        <h2>&nbsp</h2>
        <div class="content has-text-justified">
          <h3 class="title ">
            1. Vertices Layering and Sorting
          </h3>
          <img id="method_train" width="100%" src="./static/images/a1.png" alt="silksong scheme1"/>
          <p>
            The mesh vertex for layer \( L\) with order \( i\) is denoted as \( \mathcal{V}_i^L\). Given start half-edge \(\mathcal{V}_1^0\)-\(\mathcal{V}_1^1\), the vertices' layer are easily obtained based on the graph distance to \(\mathcal{V}_1^0\) via BFS algorithm. After layering, the vertices' order in layer \( L+1\) are obtained based on local order of vertices in layer \( L\). The vertices' order of first layer can be obtained based on the start half-edge, and since the vertices' order of layer \( L+1\) can be derived from layer \( L\), the remaining vertices' order can be determined through mathematical induction.
          </p>
          <h3 class="title ">
            2. Layer Adjacency Matrices Compression
          </h3>
          <img id="method_train" width="100%" src="./static/images/a2.png" alt="silksong scheme2"/>
          <p>
            All topological connections can be represented by two type of 0-1 matrices: the self-layer matrix \( \mathcal{S}_L\) and the between-layer matrix \( \mathcal{B}_L\). Suppose layer \( L\) contains \( M\) vertices and layer \( L-1\) contains \( N\) vertices. The \( \mathcal{S}_L \) with shape \( M \times M\) represents connections between vertices within layer \( L\), while \( \mathcal{B}_L \) with shape \( M \times N\) represents the connections between vertices in layer \( L\) and layer \( L-1\). We use two different algorithms to compress these matrices to tokens efficiently.
          </p>

          <h3 class="title ">
            3. Token Packing
          </h3>
          <div style="text-align: center;">
              <img id="method_train" width="50%" src="./static/images/a3.png" alt="silksong scheme3"/>
          </div>

          <p>
            For a mesh with \( N_C\) connected components, the above algorithm will be executed \( N_C\) times. To obtain the final token representation of a mesh, we use special tokens "C" and "E" to distinguish different connected components, and token "U" to separate different layers within the same connected component. A vertex's coordinate token and its corresponding matrices tokens are packed together to facilitate better pattern learning by the autoregressive model.
          </p>

        </div>
        <h2>&nbsp</h2>
        <h2 class="title is-3">Comparation</h2>
        <div class="content has-text-justified">
          <img id="comparison" width="100%" src="./static/images/c0.png" alt="Comparison with other methods"/>
          <p>
            Qualitative Comparison on <a href="https://github.com/NVlabs/EdgeRunner" target="_blank" rel="noopener noreferrer">
                EdgeRunner*</a>, <a href="https://github.com/sail-sg/TreeMeshGPT" target="_blank" rel="noopener noreferrer">
                TreeMeshGPT</a>, <a href="https://github.com/whaohan/bpt" target="_blank" rel="noopener noreferrer">
                BPT</a>, <a href="https://github.com/zhaorw02/DeepMesh" target="_blank" rel="noopener noreferrer">
                DeepMesh</a> and our method. The * denotes faithful training on the same dataset as ours. The connected components of our generated meshes are colored since our model is connected component aware based on token "C" and can capture details for minute connected components. 
          </p>
          <p>
            (1) For tree-traversal methods <a href="https://github.com/NVlabs/EdgeRunner" target="_blank" rel="noopener noreferrer">
                EdgeRunner*</a> and <a href="https://github.com/sail-sg/TreeMeshGPT" target="_blank" rel="noopener noreferrer">
                TreeMeshGPT</a>, the manifold topology for generated mesh is guaranteed, while our method demonstrates more robust generation capability and generates more details. 
          </p>
          <p>
            (2) We achieved comparable visual results compared to local patch methods <a href="https://github.com/whaohan/bpt" target="_blank" rel="noopener noreferrer">
                BPT</a> and <a href="https://github.com/zhaorw02/DeepMesh" target="_blank" rel="noopener noreferrer">
                DeepMesh</a>. However, these methods can not generate meshes with manifold topology, which hinders practical application. The non-manifold edges are colored with red for BPT and DeepMesh.
          </p>
        </div>
          
      </div>
    </div>
    <!--/ Method. -->
  </div>
</section>
   
    
    
    
   

    <section class="section" id="BibTeX">
  <div class="container is-max-desktop content">
    <h2 class="title">Acknowledgement</h2>
    We especially thank <b>Math Magic</b> 's strong support for this work.

    <h2 class="title">Citation</h2>

<pre class="selectable">
@misc{song2025meshsilksongautoregressivemesh,
      title={Mesh Silksong: Auto-Regressive Mesh Generation as Weaving Silk}, 
      author={Gaochao Song and Zibo Zhao and Haohan Weng and Jingbo Zeng and Rongfei Jia and Shenghua Gao},
      year={2025},
      eprint={2507.02477},
      archivePrefix={arXiv},
      primaryClass={cs.CV},
      url={https://arxiv.org/abs/2507.02477}, 
}
</pre>
  </div>
</section>

<footer class="footer pt-4 pb-0">
  <div class="container">
    <div class="columns is-centered">
      <div class="column is-8">
        <div class="content">
          <p>
            Website template based on
            <a href="https://github.com/nerfies/nerfies.github.io">
              Nerfies
            </a>,
            <a href="https://marigoldmonodepth.github.io/">
              Marigold
            </a>,
            <a href="https://zhaorw02.github.io/DeepMesh/">
              DeepMesh
            </a>
            and licensed under
            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
              CC-BY-SA-4.0
            </a>.
          </p>
        </div>
      </div>
    </div>
  </div>
</footer>

    
    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "./js/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

    import { PLYLoader } from './js/PLYLoader.js';
    import { OrbitControls } from './js/OrbitControls.js';
    import { GLTFLoader } from './js/GLTFLoader.js';
    


    let div_to_scene = {};
    

    let items = [
        "001",
        "002",
        "003",
        "004",
        "005",
        "006",
        "007",
        "008",
        "009",
        "010",
        "011",
        "012",
        "013",
        "014",
        "015",
        "016",
        "017",
        "018",
        "019",
        "020"
       
        

    ]
   
    let currentPage = 1;  
    let itemsPerPage = 4; 
    let totalPages = Math.ceil(items.length / itemsPerPage) || 1; 

    for (let item of items) {
        let key = `images_${item}`;
        div_to_scene[key] = { geo: null, color: null };
        key = `pc_cond_${item}`;
        div_to_scene[key] = { geo: null, color: null };
        key = `pc_${item}`;
        div_to_scene[key] = { geo: null, color: null };
    }



    let mouse_button_down = false;
    let list_of_orbit_controls = []
    let style_camera = null;
    let render_colors = true;
    let style_id = "0"

    function setup_camera(div_name){
        console.log(div_name)
        let container = document.getElementById(div_name);
        let width = container.parentElement.clientWidth;
        let height = container.parentElement.clientHeight;
        let camera = new THREE.PerspectiveCamera( 52, width / height, 0.1, 50 );

        
        
        //let camera_init_position = new THREE.Vector3( 2.25, 1.525, -3.75 );
        let camera_init_position = new THREE.Vector3( 2.25, 1.525, 3.75 );
        
        
        camera_init_position = camera_init_position.multiplyScalar(0.5)
        camera.position.set(camera_init_position.x, camera_init_position.y, camera_init_position.z);
        return camera;
    }
    

    function setup_render_divs(div_name, mesh_path){
        let camera = setup_camera(div_name)
        let orbit_control = create_render_div(camera, div_name, mesh_path)
        list_of_orbit_controls.push(orbit_control)
    }

    function setup_render_divs_pc(div_name, mesh_path){
        let camera = setup_camera(div_name)
        let orbit_control = create_point_cloud_div(camera, div_name, mesh_path)
        list_of_orbit_controls.push(orbit_control)
    }

    function clear_scenes() {
        for (let div_id in div_to_scene) {
            let container = document.getElementById(div_id);
            if (container) {
                container.innerHTML = ''; 
            }
        }
        list_of_orbit_controls = []; 
    }
    
    function render_page(page) {
        clear_scenes(); 
        let startIdx = (page - 1) * itemsPerPage; 
        let endIdx = Math.min(startIdx + itemsPerPage, items.length);
    
        for (let i = 0; i < itemsPerPage; i++) {
            let itemIdx = startIdx + i;
            if (itemIdx >= items.length) break; 
    
            let item = items[itemIdx];
            let pcDiv = `pc_00${i + 1}`;
            let pcCondDiv = `pc_cond_00${i + 1}`;
    
            setup_render_divs_pc(pcDiv, `./models/pc/${item}.ply`);
            setup_render_divs(pcCondDiv, `./models/pc_cond_ply/${item}.ply`);
            
        }
    }

    function nextPage() {
        if (currentPage < totalPages) {
            currentPage++;
            render_page(currentPage);
        }
    }

    function prevPage() {
        if (currentPage > 1) {
            currentPage--;
            render_page(currentPage);
        }
    }
    
    window.onload = function () {
        render_page(currentPage); // 初始渲染第一页
    
        
        let renderContainer = document.getElementById("render-container");
    
      
        let navContainer = document.createElement("div");
    
        navContainer.style.display = "flex";
        navContainer.style.justifyContent = "center";
        navContainer.style.gap = "50px";
        navContainer.style.marginTop = "20px";
       
        navContainer.style.padding = "10px 0";
        //navContainer.style.background = "rgba(255, 255, 255, 0.9)";
        navContainer.style.borderRadius = "8px";
    
        function styleButton(button) {
            button.style.padding = "10px 20px";
            button.style.border = "none";
            button.style.backgroundColor = "#204d93";
            button.style.color = "white";
            button.style.fontSize = "16px";
            button.style.borderRadius = "5px";
            button.style.cursor = "pointer";
            button.style.transition = "background 0.3s, transform 0.2s";
            button.onmouseover = () => (button.style.backgroundColor = "#22a7f2");
            button.onmouseout = () => (button.style.backgroundColor = "#204d93");
            button.onmousedown = () => (button.style.transform = "scale(0.95)");
            button.onmouseup = () => (button.style.transform = "scale(1)");
        }
    
        let prevButton = document.createElement("button");
        prevButton.textContent = "Back";
        prevButton.onclick = prevPage;
        styleButton(prevButton);
    
        let nextButton = document.createElement("button");
        nextButton.textContent = "Next";
        nextButton.onclick = nextPage;
        styleButton(nextButton);
    

    
    
        function updateButtons() {
            prevButton.style.display = currentPage === 1 ? "none" : "block";
            nextButton.style.display = currentPage === totalPages ? "none" : "block";
        }
        
        /*function updateButtons() {
            if (currentPage === 0) {
                prevButton.style.display = "none"; 
            } else {
                prevButton.style.display = "block";
            }

            if (currentPage === totalPages - 1) {
                nextButton.style.display = "none"; 
            } else {
                nextButton.style.display = "block";
            }
        }*/
    
       
        navContainer.appendChild(prevButton);
        //navContainer.appendChild(pageIndicator);
        navContainer.appendChild(nextButton);
    
      
        if (renderContainer) {
            renderContainer.appendChild(navContainer);
            //updatePageIndicator(); // 首次加载时创建指示器
        }
    };


    function create_point_cloud_div(camera, div_id, point_cloud_path) {
        let container;
        let renderer, controls;
    
        init();
        animate();
    
        function init() {
            container = document.getElementById(div_id);
            let width = container.parentElement.clientWidth;
            let height = container.parentElement.clientHeight;
    
            div_to_scene[div_id]["color"] = new THREE.Scene();
            div_to_scene[div_id]["geo"] = new THREE.Scene();
            div_to_scene[div_id]["color"].background = new THREE.Color( 0xffffff );
            div_to_scene[div_id]["geo"].background = new THREE.Color( 0xffffff );

            // PLY file
            const loader = new PLYLoader();
            loader.load( point_cloud_path, function ( geometry ) {
                
                
                const material = new THREE.PointsMaterial({ color: 0x204d93, size: 0.02 });

                
                const points = new THREE.Points(geometry, material);
                const points2 = new THREE.Points(geometry, material);

                div_to_scene[div_id]["geo"].add( points );
                div_to_scene[div_id]["color"].add( points2 );

            }, (xhr) => {
                console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
            }, (error) => {
                console.log('load fail')
                console.log(error)
            }
            );
    
            div_to_scene[div_id]["color"].add( new THREE.HemisphereLight( 0x333333, 0x222222 ) );
            div_to_scene[div_id]["geo"].add( new THREE.HemisphereLight( 0x333333, 0x222222 ) );
            addShadowedLight(div_to_scene[div_id]["color"], 1, 1, 1, 0xffffff, 1.35 / 2 );
            addShadowedLight(div_to_scene[div_id]["color"],  0.5, 1, - 1, 0xffffff, 1 / 2 );
            addShadowedLight(div_to_scene[div_id]["geo"], 1, 1, 1, 0xffffff, 1.35 );
            addShadowedLight(div_to_scene[div_id]["geo"],  0.5, 1, - 1, 0xffffff, 1 );
    
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);
            renderer.outputEncoding = THREE.sRGBEncoding;
    
            renderer.shadowMap.enabled = true;
    
            container.appendChild(renderer.domElement);
    
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = false;
    
            // Resize
            window.addEventListener('resize', onWindowResize);
        }
    
        function onWindowResize() {
            let width = container.clientWidth;
            let height = container.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize( width, height );
        }
        function animate() {
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            renderer.render( div_to_scene[div_id][render_colors ? "color" : "geo"], camera );
            controls.update();
        }

        return controls;
    }

   

    function create_render_div(camera, div_id, mesh_path) {
        let container;
        let renderer, controls;

        init();
        animate();

        function init() {

            container = document.getElementById(div_id);
            let width = container.parentElement.clientWidth;
            let height = container.parentElement.clientHeight;

            div_to_scene[div_id]["color"] = new THREE.Scene();
            div_to_scene[div_id]["geo"] = new THREE.Scene();
            div_to_scene[div_id]["color"].background = new THREE.Color( 0xffffff );
            div_to_scene[div_id]["geo"].background = new THREE.Color( 0xffffff );

            // PLY file
            // console.log(mesh_path)
            const loader = new PLYLoader();
            loader.load( mesh_path, function ( geometry ) {
              
                geometry.computeVertexNormals();
                    
                // let start_color = new THREE.Color(0.416, 0.106, 0.604); // 紫色
                // let end_color = new THREE.Color(1.0, 0.976, 0.769);     // 黄色

              
                // let position = geometry.attributes.position;
                // let minY = Infinity, maxY = -Infinity;
                // for (let i = 0; i < position.count; i++) {
                //     let y = position.getY(i);
                //     if (y < minY) minY = y;
                //     if (y > maxY) maxY = y;
                // }
                // let deltaY = maxY - minY || 1; 
                
                // let colors = new Float32Array(position.count * 3);
                // for (let i = 0; i < position.count; i++) {
                //     let t = (position.getY(i) - minY) / deltaY; 
                //     let color = new THREE.Color(
                //         start_color.r * (1 - t) + end_color.r * t,
                //         start_color.g * (1 - t) + end_color.g * t,
                //         start_color.b * (1 - t) + end_color.b * t
                //     );
                //     colors[i * 3] = color.r;
                //     colors[i * 3 + 1] = color.g;
                //     colors[i * 3 + 2] = color.b;
                // }

               
                // geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                let material_color = new THREE.MeshStandardMaterial({
                    vertexColors: true, 
                    flatShading: true,
                    side: THREE.DoubleSide
                });
                let material_geo = new THREE.MeshStandardMaterial({
                    vertexColors: true, // 启用顶点颜色
                    flatShading: true,
                    side: THREE.DoubleSide
                });

                // let material_color = new THREE.MeshStandardMaterial( { color: 0x4169E1, flatShading: true, side: THREE.DoubleSide } )
                //let material_geo = new THREE.MeshStandardMaterial( { color: 0x2e4e8c, flatShading: true, side: THREE.DoubleSide } )

                let wireframe = new THREE.WireframeGeometry( geometry );
                let line = new THREE.LineSegments( wireframe );
                
                line.material.color.setHex(0x000000);
       
                
               

                const mesh_color = new THREE.Mesh( geometry, material_color );
                const mesh_geo = new THREE.Mesh( geometry, material_geo );

                div_to_scene[div_id]["color"].add( mesh_color );
                div_to_scene[div_id]["color"].add(line);
                div_to_scene[div_id]["geo"].add( mesh_geo );

            }, (xhr) => {
                console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
            }, (error) => {
                console.log('load fail')
                console.log(error)
            }
            );

            // lights

            //div_to_scene[div_id]["color"].add( new THREE.HemisphereLight( 0x333333, 0x222222 ) );
            //div_to_scene[div_id]["geo"].add( new THREE.HemisphereLight( 0x333333, 0x222222 ) );

            /*addShadowedLight(div_to_scene[div_id]["color"], 1, 1, 1, 0xffffff, 1.35 / 2 );
            addShadowedLight(div_to_scene[div_id]["color"],  0.5, 1, - 1, 0xffffff, 1 / 2 );
            addShadowedLight(div_to_scene[div_id]["geo"], 1, 1, 1, 0xffffff, 1.35 );
            addShadowedLight(div_to_scene[div_id]["geo"],  0.5, 1, - 1, 0xffffff, 1 );*/
            // 1. 添加环境光（均匀照亮所有面）
            let ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            div_to_scene[div_id]["color"].add(ambientLight);
            div_to_scene[div_id]["geo"].add(ambientLight.clone());

            // 2. 添加半球光（让整体光照更自然）
            let hemiLight = new THREE.HemisphereLight(0xffffff, 0x888888, 0.6);
            hemiLight.position.set(0, 10, 0);
            div_to_scene[div_id]["color"].add(hemiLight);
            div_to_scene[div_id]["geo"].add(hemiLight.clone());
            

            // renderer

            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( width, height);
            renderer.outputEncoding = THREE.sRGBEncoding;

            renderer.shadowMap.enabled = true;

            container.appendChild( renderer.domElement );

            controls = new OrbitControls(camera, renderer.domElement)
            controls.enableDamping = false

            // resize

            window.addEventListener( 'resize', onWindowResize );

    }
        function onWindowResize() {
            let width = container.clientWidth;
            let height = container.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize( width, height );
        }
        function animate() {
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            renderer.render( div_to_scene[div_id][render_colors ? "color" : "geo"], camera );
            controls.update();
        }

        return controls;
    }


    function addShadowedLight(scene, x, y, z, color, intensity ) {
    

    }

    document.addEventListener('keydown', logKey);

    function logKey(evt) {
        if (evt.keyCode === 71 && !mouse_button_down) {
            switch_geometry()
        }
        if (evt.keyCode === 82 && !mouse_button_down) {
            list_of_orbit_controls.forEach(oc => {
                console.log(oc.object.position)
            })
            reset_orbit_controls()
        }
    }

    function switch_geometry() {
        render_colors = !render_colors
    }

    function reset_orbit_controls() {
        list_of_orbit_controls.forEach(oc => {
            oc.reset()
        })
    }

    function set_style_0(){
        style_id = "0"
    }

    function set_style_1(){
        style_id = "1"
    }

    function set_style_2(){
        style_id = "2"
    }

    document.body.onmousedown = function(evt) {
        if (evt.button === 0)
            mouse_button_down = true
    }
    document.body.onmouseup = function(evt) {
        if (evt.button === 0)
            mouse_button_down = false
    }

    

    </script>

    

</body>

</html>
